////Сортировка выбором
Находится самый маленький и меняется местами с первым. Теперь первый элемент упорядочен, происходит поиск следующего минимального элемента, замена и т.д.

int* SortBySelection(int* a, int size)
{
    int j = 0;
    int c = 0;
    for (int i = 0; i < size; i++) {
        j = i;
        for (int k = i; k < size; k++) {
            if (a[j] > a[k]) {
                j = k; //индекс минимума
            }
        }
        swap(a[i], a[j]);
    }
    return a;
}

/////Сортировка пузырьком
Попарное сравнение элементов, при этом больший как бы "всплывает", подобно пузырьку, вверх, к концу массива. Если поменять знак, все будет в порядке убывания.


int* BubbleSort(int* a, int size)
{
    for (int i = 0; i < size; i++) 
    {
        for (int j = 0; j < size-1; j++)
        {
            if (a[j] > a[j + 1])
            {
                swap(a[j], a[j + 1]);
            }
        }
    }
    return a;
}

/////Сортировка вставками
При сортировке вставками массив разбивается на две области: упорядоченную и и неупорядоченную. 
Изначально весь массив является неупорядоченной областью, кроме первого. При первом проходе первый элемент из неупорядоченной области изымается 
и помещается в правильном положении в упорядоченной области. На каждом проходе размер упорядоченной области возрастает на 1, а размер неупорядоченной области сокращается на 1.

int* InsertionSort(int* a, int size)
{
    int delta;
    int j; 
    for (int i = 1; i < size; i++)
    {
        delta = a[i]; 
        j = i-1; 
        while (j >= 0 && a[j] > delta)
        {
            swap(a[j], a[j + 1]);
            j--;
        }
    }
    return a;
}



////Сортировка слиянием
Последовательность рекурсивно разделяется на подмассивы. После этого алгоритм сливает единичные массивы попарно до тех пор, пока не получится один массив, 
все элементы которого стоят на своих позициях.

void Merge(int* a, int first, int last)
{
    int middle, start, final, j;
    int* mas = new int[100];
    middle = (first + last) / 2; //медиана
    start = first; //начало левой части
    final = middle + 1; //начало правой части
    for (j = first; j <= last; j++) //выполнять от начала до конца
        if ((start <= middle) && ((final > last) || (a[start] < a[final])))
        {
            mas[j] = a[start];
            start++;
        }
        else
        {
            mas[j] = a[final];
            final++;
        }
    for (j = first; j <= last; j++) a[j] = mas[j];
};

int* MergeSort(int* a, int first, int last) //номера 1-го и последнего элементов
{
    {
        if (first < last)
        {
            MergeSort(a, first, (first + last) / 2); //сортировка левой части
            MergeSort(a, (first + last) / 2 + 1, last); //сортировка правой части
            Merge(a, first, last); //слияние двух частей
        }
    }
    return a;
};


////Быстрая сортировка
Выбрать опорный элемент в массиве — часто встречается вариант с центральным элементом.
Разделить массив на две части следующим образом: все элементы из левой части, которые больше или равны опорному, перекидываем в правую, аналогично, 
все элементы из правой, которые меньше или равны опорному кидаем в левую часть.
В результате предыдущего шага в левой части массива останутся элементы, которые меньше или равны центральному, а в правой — больше либо равны.
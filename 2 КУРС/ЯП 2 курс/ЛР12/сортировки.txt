////Сортировка выбором
Находится самый маленький и меняется местами с первым. Теперь первый элемент упорядочен, происходит поиск следующего минимального элемента, замена и т.д.

int* SortBySelection(int* a, int size)
{
    int j = 0;
    int c = 0;
    for (int i = 0; i < size; i++) {
        j = i;
        for (int k = i; k < size; k++) {
            if (a[j] > a[k]) {
                j = k; //индекс минимума
            }
        }
        swap(a[i], a[j]);
    }
    return a;
}

/////Сортировка пузырьком (обменная)
Попарное сравнение элементов, при этом больший как бы "всплывает", подобно пузырьку, вверх, к концу массива. Если поменять знак, все будет в порядке убывания.


int* BubbleSort(int* a, int size)
{
    for (int i = 0; i < size; i++) 
    {
        for (int j = 0; j < size-1; j++)
        {
            if (a[j] > a[j + 1])
            {
                swap(a[j], a[j + 1]);
            }
        }
    }
    return a;
}

////Шейкерная (пузырьковая с двух сторон)
int* ShakerSort(int* a, int size)
{
    int left = 0, i;
    int right = size - 1;
        while (left <= right)
        {
            for (i = right; i >= left; i--)
                if (a[i-1] > a[i]) swap(a[i], a[i-1]);
            left++;
            for (i = left; i <= right; i++)
                if (a[i-1] > a[i]) swap(a[i], a[i-1]);
            right--;
        }
    return a;
}

////Расчёска (comb sort)
Идея в том, чтобы сравнивать элементы не с соседним, а со стоящим на некотором расстоянии. Чтобы пузырьки быстрее всплывали. 
Постепенно уменьшая интервал этих обменов, как бы расчёсываем массив. В качестве наиболее эффективных коэффициентов сокращения называют 1.3 и 1.2473309. 
Второй получен из математических соображений. Но как показали нижеприведённые замеры на реальном железе, результаты с простым коэффициентом 1.3 получше.

int* CombSort(int* a, int size) //расческа
{
    double faktor = 1.2473309; 
    int step = size;
    bool swapped = true; // условие выполнения цикла
    while (step != 1 || swapped) { //пока разрыв больше 1 и была сделана замена
        step = step / faktor;
        if (step < 1)
            step = 1;
        swapped = false;
        for (int i = 0; i < size - step; ++i) //сравнение всех элементов с текущим разрывом
            if (a[i] > a[i + step]) {
                swap(a[i], a[i + step]);
                swapped = true;
            }
    }
    return a;
}

////6. ???  

int* CopySort(int* a, int size) 
{
    int* subArray = new int[size];
    int j = 0, counter = 0;
    for (int i = 0; i < size; i++) 
    {
        subArray[i] = -1;
    }
    for (int i = 0; i < size; i++)
    {
        counter = 0;
        for (int j = 0; j < size; j++)
        {
            if (a[j] < a[i]) counter++;
        }
        subArray[counter] = a[i];
    }
    for (int i = 0; i < size; i++)
    {
        if (subArray[i] == -1)
        {
            j = i;
            while (subArray[j] == -1)
            {
                subArray[j] = subArray[i-1];
                j++;
            }
        }
    }
    return subArray;
}


////7/ сортировка подсчётом
В этом алгоритме используется диапазон чисел сортируемого массива для подсчѐта совпадающих элементов.
Cортировка подсчетом усовершенствована тем, что находит минимум и максимум в вашем массиве, тем самым сокращая дополнительный массив, который необходим для хванения промежуточных данных.

int* CalculationSort(int* a, int size) 
{
    int max = 1e-6, min = 1e6;
    for (int i = 0; i < size; i++) {
        if (a[i] > max)
            max = a[i];
        if (a[i] < min)
            min = a[i];
    }
    int* c = new int[max + 1 - min];
    for (int i = 0; i < max + 1 - min; i++) {
        c[i] = 0;
    }
    for (int i = 0; i < size; i++) {
        c[a[i] - min] = c[a[i] - min] + 1;
    }
    int i = 0;
    for (int j = min; j < max + 1; j++) {
        while (c[j - min] != 0) {
            a[i] = j;
            c[j - min]--;
            i++;
        }
    }
    return a;
}


/////Сортировка вставками
При сортировке вставками массив разбивается на две области: упорядоченную и и неупорядоченную. 
Изначально весь массив является неупорядоченной областью, кроме первого. При первом проходе первый элемент из неупорядоченной области изымается 
и помещается в правильном положении в упорядоченной области. На каждом проходе размер упорядоченной области возрастает на 1, а размер неупорядоченной области сокращается на 1.

int* InsertionSort(int* a, int size)
{
    int delta;
    int j; 
    for (int i = 1; i < size; i++)
    {
        delta = a[i]; 
        j = i-1; 
        while (j >= 0 && a[j] > delta)
        {
            swap(a[j], a[j + 1]);
            j--;
        }
    }
    return a;
}



////Сортировка слиянием
Последовательность рекурсивно разделяется на подмассивы. После этого алгоритм сливает единичные массивы попарно до тех пор, пока не получится один массив, 
все элементы которого стоят на своих позициях.

void Merge(int* a, int first, int last)
{
    int middle, start, final, j;
    int* mas = new int[100];
    middle = (first + last) / 2; //медиана
    start = first; //начало левой части
    final = middle + 1; //начало правой части
    for (j = first; j <= last; j++) //выполнять от начала до конца
        if ((start <= middle) && ((final > last) || (a[start] < a[final])))
        {
            mas[j] = a[start];
            start++;
        }
        else
        {
            mas[j] = a[final];
            final++;
        }
    for (j = first; j <= last; j++) a[j] = mas[j];
};

int* MergeSort(int* a, int first, int last) //номера 1-го и последнего элементов
{
    {
        if (first < last)
        {
            MergeSort(a, first, (first + last) / 2); //сортировка левой части
            MergeSort(a, (first + last) / 2 + 1, last); //сортировка правой части
            Merge(a, first, last); //слияние двух частей
        }
    }
    return a;
};


////Быстрая сортировка
Выбрать опорный элемент в массиве — часто встречается вариант с центральным элементом.
Разделить массив на две части следующим образом: все элементы из левой части, которые больше или равны опорному, перекидываем в правую, аналогично, 
все элементы из правой, которые меньше или равны опорному кидаем в левую часть.
В результате предыдущего шага в левой части массива останутся элементы, которые меньше или равны центральному, а в правой — больше либо равны.